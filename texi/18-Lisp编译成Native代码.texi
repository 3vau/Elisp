\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename 18-Lisp编译成Native代码.info
@settitle 
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@finalout
@titlepage
@title 
@author zunrong
@end titlepage

@contents

@ifnottex
@node Top
@top 
@end ifnottex

@menu
* 18 Lisp编译成Native代码::

@detailmenu
--- The Detailed Node Listing ---

18 Lisp编译成Native代码

* 18.1 本机编译函数: 181 本机编译函数. 
* 18.2 本机编译变量: 182 本机编译变量. 

@end detailmenu
@end menu

@node 18 Lisp编译成Native代码
@chapter 18 Lisp编译成Native代码

除了上一章中描述的字节编译之外，Emacs 还可以选择性地将 Lisp 函数定义编译成真正的编译代码，称为本地代码。此功能使用 libgccjit 库，它是 GCC 发行版的一部分，并且要求构建 Emacs 时支持使用该库。它还需要在您的系统上安装 GCC 和 Binutils（汇编器和链接器），以便您能够本地编译 Lisp 代码。

要确定当前 Emacs 进程是否可以生成和加载本机编译的 Lisp 代码，请调用 native-comp-available-p（请参阅 Native-Compilation Functions）。

与字节编译的代码不同，本机编译的 Lisp 代码直接由机器硬件执行，因此以主机 CPU 可以提供的全速运行。最终的加速通常取决于 Lisp 代码的作用，但通常比相应的字节编译代码快 2.5 到 5 倍。

由于本机代码通常在不同系统之间不兼容，本机编译的代码不能从一台机器传输到另一台机器，它只能在产生它的同一台机器上或非常相似的机器上使用（具有相同的 CPU 和运行时间图书馆）。本机编译代码的可传输性与共享库（.so 或 .dll 文件）的可传输性相同。

本机编译代码的库包括对 Emacs Lisp 原语的关键依赖项（请参阅什么是函数？）及其调用约定，因此 Emacs 通常不会加载由早期或更高版本的 Emacs 生成的本机编译代码；  不同 Emacs 版本对相同 Lisp 代码的本地编译通常会以唯一文件名生成一个本地编译库，只有该版本的 Emacs 才能加载该库。然而，使用唯一文件名允许在同一个目录中拥有由几个不同版本的 Emacs 本地编译的同一个 Lisp 库的多个版本。

no-byte-compile 的非 nil 文件局部变量绑定（请参阅字节编译）也会禁用该文件的本机编译。此外，类似的变量 no-native-compile 仅禁用文件的本机编译。如果同时指定了 no-byte-compile 和 no-native-compile，则前者优先。

@menu
* 18.1 本机编译函数: 181 本机编译函数. 
* 18.2 本机编译变量: 182 本机编译变量. 
@end menu

@node 181 本机编译函数
@section 18.1 本机编译函数

Native-Compilation 是作为字节编译的副作用实现的（请参阅字节编译）。因此，以本机方式编译 Lisp 代码也总是生成其字节码，因此为字节编译准备 Lisp 代码的所有规则和注意事项（请参阅字节编译函数）也适用于本机编译。

您可以使用 native-compile 函数本地编译单个函数或宏定义，或整个 Lisp 代码文件。本机编译文件将生成相应的带有字节码的 .elc 文件和带有本机代码的 .eln 文件。

本机编译可能会产生警告或错误消息；  这些通常记录在名为 @strong{Native-compile-Log} 的缓冲区中。在交互式会话中，它使用特殊的 LIMPLE 模式（native-comp-limple-mode），该模式会根据该日志设置 font-lock，否则与 Fundamental 模式相同。本地编译产生的消息的日志记录可以由 native-comp-verbose 变量控制（请参阅 Native-Compilation 变量）。

当 Emacs 以非交互方式运行时，本机编译产生的消息通过调用 message 报告（请参阅在 Echo 区域显示消息），并且通常显示在调用 Emacs 的终端的标准错误流上。

@lisp
Function: native-compile function-or-file &optional output ¶
@end lisp

此函数将函数或文件编译为本机代码。参数 function-or-file 可以是函数符号、Lisp 形式或包含要编译的 Emacs Lisp 源代码的文件的名称（字符串）。如果提供了可选参数输出，它必须是一个字符串，指定要写入编译代码的文件的名称。否则，如果 function-or-file 是函数或 Lisp 形式，则此函数返回编译后的对象，如果 function-or-file 是文件名，则函数返回它为编译后创建的文件的完整绝对名称代码。默认情况下，输出文件的扩展名为 .eln。

该函数在一个单独的子进程中运行本机编译的最后阶段，通过 libgccjit 调用 GCC，该子进程调用与调用该函数的进程相同的 Emacs 可执行文件。

@lisp
Function: batch-native-compile &optional for-tarball ¶
@end lisp

此函数以批处理模式对 Emacs 命令行上指定的文件运行本机编译。它只能在 Emacs 的批处理执行中使用，因为它会在编译完成时杀死 Emacs。如果一个或多个文件编译失败，Emacs 进程将尝试编译所有其他文件，并以非零状态码终止。tarball 的可选参数，如果不是 nil，则告诉函数将生成的 .eln 文件放在 native-comp-eln-load-path 中提到的最后一个目录中（请参阅库搜索）；  这是第一次用作构建 Emacs 源 tarball 的一部分，当源 tarball 中不存在的本机编译文件应该在构建树而不是用户的缓存目录中生成时。

本机编译可以完全异步运行，在主 Emacs 进程的子进程中。这使得主 Emacs 进程可以在编译在后台运行时自由使用。这是 Emacs 在没有可用的本机编译文件时对加载到 Emacs 的任何 Lisp 文件或字节编译的 Lisp 文件进行本机编译的方法。请注意，由于使用了子进程，本机编译可能会产生字节编译不会产生的警告和错误，因此可能需要修改 lisp 代码才能正常工作。有关更多详细信息，请参阅本地编译变量中的 native-comp-async-report-warnings-errors。

@lisp
Function: native-compile-async files &optional recursively load selector ¶
@end lisp

此函数异步编译命名文件。参数文件应该是单个文件名（字符串）或一个或多个文件和/或目录名称的列表。如果列表中存在目录，则可选参数递归地应为非零，以使编译递归到这些目录中。如果 load 不为零，Emacs 将加载它成功编译的每个文件。可选参数选择器允许控制将编译哪些文件；  它可以具有以下值之一：

@lisp
nil or omitted
@end lisp

选择文件中的所有文件和目录。
@lisp
a regular expression string
@end lisp

选择名称与正则表达式匹配的文件和目录。
@lisp
a function
@end lisp
一个谓词函数，它将与 files 中的每个文件和目录一起调用，如果应该选择文件或目录进行编译，则应该返回非 nil。

在具有多个 CPU 执行单元的系统上，当文件命名多个文件时，此函数通常会在 native-comp-async-jobs-number 的控制下并行启动多个编译子进程（参见 Native-Compilation Variables）。

下面的函数允许 Lisp 程序在运行时测试本地编译是否可用。

@lisp
Function: native-comp-available-p ¶
@end lisp

如果正在运行的 Emacs 进程已编译了本机编译支持，则此函数返回非 nil。在动态加载 libgccjit 的系统上，它还确保库可用并且可以加载。需要预先知道本机编译是否可用的 Lisp 程序应该使用这个谓词。

@node 182 本机编译变量
@section 18.2 本机编译变量

本节记录了控制本机编译的变量。

@lisp
User Option: native-comp-speed ¶
@end lisp

此变量指定本机编译的优化级别。它的值应该是介于 -1 和 3 之间的一个数字。介于 0 和 3 之间的值指定与编译器的相应编译器 -O0、-O1 等命令行选项等效的优化级别。值 -1 表示禁用本机编译；  函数和文件将仅进行字节编译。默认值为 2。

@lisp
User Option: native-comp-debug ¶
@end lisp

此变量指定本机编译产生的调试信息级别。它的值应该是一个介于 0 和 3 之间的数字，含义如下：

@lisp
0
@end lisp

没有调试输出。这是默认设置。
@lisp
1
@end lisp

使用本机代码发出调试符号。这允许使用 gdb 等调试器更轻松地调试本机代码。
@lisp
2
@end lisp

像 1，另外转储伪 C 代码。
@lisp
3
@end lisp

像 2，另外转储 GCC 中间通道和 libgccjit 日志文件。

@lisp
User Option: native-comp-verbose ¶
@end lisp

此变量通过抑制其发出的部分或全部日志消息来控制本机编译的详细程度。如果它的值为零，默认情况下，所有日志消息都被抑制。将其设置为 1 到 3 之间的值将允许记录其级别高于该值的消息。这些值具有以下解释：

@lisp
0
@end lisp

没有记录。这是默认设置。
@lisp
1
@end lisp

记录代码的最终 LIMPLE 表示。
@lisp
2
@end lisp

记录 LAP、最后的 LIMPLE 和一些额外的通行证信息。
@lisp
3
@end lisp

最大冗长：记录所有内容。

@lisp
User Option: native-comp-async-jobs-number ¶
@end lisp

此变量确定将同时启动的本机编译子进程的最大数量。它应该是一个非负数。默认值为 0，表示使用 CPU 执行单元数的一半，如果 CPU 只有一个执行单元，则为 1。

@lisp
User Option: native-comp-async-report-warnings-errors ¶
@end lisp

如果此变量的值为非零，则来自异步本机编译子进程的警告和错误将在名为 @strong{Warnings} 的缓冲区中的主 Emacs 会话中报告。默认值 t 表示显示结果缓冲区。要在不弹出 @strong{Warnings} 缓冲区的情况下记录警告，请将此变量设置为静默。

异步本机编译产生警告的一个常见原因是编译缺少某些必要功能要求的文件。该功能可能会加载到主 emacs 中，但由于本机编译总是从具有原始环境的子进程开始，因此子进程可能并非如此。

@lisp
User Option: native-comp-async-query-on-exit ¶
@end lisp

如果该变量的值为非 nil，Emacs 将在退出时询问是否退出并杀死任何仍在运行的异步原生编译子进程，从而阻止写入相应的 .eln 文件。如果值为 nil，默认值，Emacs 将杀死这些子进程而不进行查询。

@bye