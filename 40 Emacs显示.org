#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: elegantpaper
#+OPTIONS: prop:t
#+OPTIONS: ^:nil

* TODO 40 Emacs显示
本章描述了许多与 Emacs 呈现给用户的显示相关的特性。

** TODO 40.1 刷新屏幕

函数 redraw-frame 清除并重新显示给定帧的全部内容（请参阅帧）。  如果屏幕损坏，这很有用。

 功能：重绘框架&可选框架¶

     该函数清除并重新显示帧帧。  如果 frame 被省略或为零，它会重绘选定的帧。

 更强大的是重绘显示：

 命令：重绘显示¶

     此函数清除并重新显示所有可见帧。

 在 Emacs 中，处理用户输入优先于重新显示。  如果在输入可用时调用这些函数，它们不会立即重新显示，但请求的重新显示最终会发生——在所有输入都已处理之后。

 在文本终端上，挂起和恢复 Emacs 通常也会刷新屏幕。  一些终端仿真器为 Emacs 等面向显示的程序和普通的顺序显示记录单独的内容。  如果您正在使用这样的终端，您可能希望在恢复时禁止重新显示。

 用户选项： no-redraw-on-reenter ¶

     此变量控制 Emacs 在暂停和恢复后是否重绘整个屏幕。  Non-nil 表示不需要重绘，nil 表示需要重绘。  默认值为无。

** TODO 40.2 强制重新显示

Emacs 通常会在等待输入时尝试重新显示屏幕。  使用以下函数，您可以在 Lisp 代码中间请求立即尝试重新显示，而无需实际等待输入。

 功能：重新显示&可选力¶

     此函数会立即尝试重新显示。  可选参数 force，如果非零，则强制执行重新显示，而不是在输入未决时被抢占。

     如果函数实际尝试重新显示，则返回 t，否则返回 nil。  t 值并不意味着重新显示已完成；  它可能已被新到达的输入抢占。

 尽管 redisplay 会立即尝试重新显示，但它不会改变 Emacs 决定重新显示其帧的哪些部分的方式。  相比之下，以下函数将某些窗口添加到挂起的重新显示工作（好像它们的内容已经完全改变），但不会立即尝试执行重新显示。

 功能：强制窗口更新&可选对象¶

     此函数强制在 Emacs 下一次重新显示时更新部分或所有窗口。  如果对象是一个窗口，则该窗口将被更新。  如果 object 是缓冲区或缓冲区名称，则显示该缓冲区的所有窗口都将被更新。  如果 object 为 nil（或省略），则所有窗口都将被更新。

     此功能不会立即重新显示；  Emacs 在等待输入或调用函数 redisplay 时会这样做。

 变量：pre-redisplay-function ¶

     一个函数在重新显示之前运行。  它使用一个参数调用，即要重新显示的一组窗口。  该集合可以为 nil，表示仅选定的窗口，或 t，表示所有窗口。

 变量：pre-redisplay-functions ¶

     这个钩子在重新显示之前运行。  它在即将重新显示的每个窗口中调用一次，当前缓冲区设置为该窗口中显示的缓冲区。

** TODO 40.3 截断

当一行文本超出窗口的右边缘时，Emacs 可以继续该行（使其换行到下一个屏幕行），或截断该行（将其限制为一个屏幕行）。  用于显示长文本行的附加屏幕行称为续行。  延续不等于填充；  延续只发生在屏幕上，不在缓冲区内容中，它在右边距而不是在单词边界处断行。  请参阅填充。

 在图形显示上，窗口边缘中的微小箭头图像表示截断和连续的线条（请参阅边缘）。  在文本终端上，窗口最右列中的“$”表示截断；  最右边一列的“\”表示换行。  （显示表可以指定用于此的替代字符；请参阅显示表）。

 由于文本的换行和截断相互矛盾，Emacs 在请求换行时关闭行截断，反之亦然。

 用户选项：截断行¶

     如果此缓冲区局部变量为非 nil，则超出窗口右边缘的行将被截断；  否则，它们将继续。  作为一个特殊的例外，变量 truncate-partial-width-windows 在部分宽度窗口（即不占据整个框架宽度的窗口）中具有优先权。

 用户选项：截断部分宽度窗口¶

     此变量控制部分宽度窗口中的行截断。  部分宽度窗口是不占据整个框架宽度的窗口（请参阅拆分窗口）。  如果值为 nil，则行截断由变量 truncate-lines 确定（见上文）。  如果该值为整数 n，则如果部分宽度窗口的列少于 n 列，则将截断行，而不管 truncate-lines 的值如何；  如果部分宽度窗口有 n 列或更多列，则行截断由 truncate-lines 确定。  对于任何其他非 nil 值，无论 truncate-lines 的值如何，每个部分宽度窗口中的行都会被截断。

 在窗口中使用水平滚动（请参阅水平滚动）时，会强制截断。

 变量：换行前缀¶

     如果这个缓冲区局部变量不是 nil，它定义了一个 wrap 前缀，Emacs 会在每个续行的开头显示该前缀。  （如果行被截断，则从不使用 wrap-prefix。）它的值可以是字符串或图像（请参阅其他显示规范），或者是由 :width 或 :align-to 显示属性指定的一段空白（见指定空间）。  该值的解释方式与显示文本属性相同。  请参阅显示属性。

     也可以使用 wrap-prefix text 或 overlay 属性为文本区域指定换行前缀。  这优先于 wrap-prefix 变量。  请参阅具有特殊含义的属性。

 变量：行前缀¶

     如果这个缓冲区局部变量不是 nil，它定义了一个行前缀，Emacs 会在每个非连续行的开头显示该行前缀。  它的值可以是字符串或图像（请参阅其他显示规范），或者是由 :width 或 :align-to 显示属性指定的一段空白（请参阅指定的空格）。  该值的解释方式与显示文本属性相同。  请参阅显示属性。

     也可以使用 line-prefix text 或 overlay 属性为文本区域指定行前缀。  这优先于行前缀变量。  请参阅具有特殊含义的属性。

** TODO 40.4 回声区

回显区域用于显示错误消息（请参阅错误）、使用消息原语生成的消息以及回显击键。  它与 minibuffer 不同，尽管 minibuffer 出现在屏幕上与回声区域相同的位置（当激活时）。  请参阅 GNU Emacs 手册中的 Minibuffer。

 除了本节中记录的函数之外，您还可以通过将 t 指定为输出流来将 Lisp 对象打印到回显区域。  请参阅输出流。

*** TODO 40.4.1 在回显区显示消息

本节介绍在回显区域中显示消息的标准功能。

 功能：消息格式字符串 &rest 参数 ¶

     此功能在回显区域显示一条消息。  format-string 是一个格式字符串，参数是其格式规范的对象，就像在 format-message 函数中一样（请参阅格式化字符串）。  生成的格式化字符串显示在回显区域；  如果它包含人脸文本属性，它会与指定的人脸一起显示（请参阅人脸）。  该字符串也被添加到 *Messages* 缓冲区，但没有文本属性（请参阅在 *Messages* 中记录消息）。

     通常，格式中的重音和撇号会转换为匹配的弯引号，例如，“Missing `%s'”可能会导致“Missing 'foo'”。  有关如何影响或禁止此翻译的信息，请参阅文本引用样式。

     在批处理模式下，消息被打印到标准错误流，后跟换行符。

     当 inhibitor-message 为非 nil 时，回显区域不会显示任何消息，只会记录到 '*Messages*'。

     如果 format-string 为 nil 或空字符串，则 message 清除回显区域；  如果回声区域已自动扩展，则会将其恢复到正常大小。  如果 minibuffer 处于活动状态，这会将 minibuffer 内容立即带回屏幕。

     （消息“正在恢复 `%s'...”（缓冲区名称））
      -|  正在恢复“subr.el”...
     ⇒ “正在恢复 'subr.el'...”


     ---------- 回声区 ----------
     正在恢复“subr.el”...
     ---------- 回声区 ----------

     要根据消息的大小在回显区域或弹出缓冲区中自动显示消息，请使用 display-message-or-buffer（见下文）。

     警告：如果您想将自己的字符串逐字用作消息，请不要只写（消息字符串）。  如果字符串包含 '%'、'`' 或 ''' 它可能会被重新格式化，从而产生不希望的结果。  而是使用 (message "%s" 字符串)。

 变量：set-message-function ¶

     如果此变量非零，它应该是一个参数的函数，即在回显区域中显示的消息文本。  该函数将被消息和相关函数调用。  如果函数返回 nil，则消息将照常显示在回显区域中。  如果此函数返回一个字符串，则该字符串将显示在回显区域而不是原始字符串。  如果此函数返回其他非零值，则表示该消息已被处理，因此消息不会在回显区域显示任何内容。  另见 clear-message-function 可用于清除此函数显示的消息。

     默认值是当 minibuffer 处于活动状态时在 minibuffer 末尾显示消息的函数。  但是，如果活动小缓冲区中显示的文本在某些字符上具有 minibuffer-message 文本属性（请参阅具有特殊含义的属性），则消息将在具有该属性的第一个字符之前显示。

 变量：clear-message-function ¶

     如果此变量为非 nil，则 message 和相关函数在其参数 message 为 nil 或空字符串时不带参数调用它。

     通常在显示回显区域消息后下一个输入事件到达时调用此函数。  该函数应清除由 set-message-function 指定的对应函数显示的消息。

     默认值是清除活动小缓冲区中显示的消息的函数。

 变量：禁止消息¶

     当此变量为非零时，消息和相关函数将不会使用回显区域来显示消息。

 宏：with-temp-message message &rest body ¶

     此构造在执行主体期间临时在回显区域中显示一条消息。  它显示消息，执行正文，然后返回最后一个正文形式的值，同时恢复先前的回显区域内容。

 功能：消息或框格式字符串 &rest 参数 ¶

     此功能显示类似消息的消息，但可能会在对话框而不是回显区域中显示它。  如果在使用鼠标调用的命令中调用此函数（更准确地说，如果 last-nonmenu-event（请参阅命令循环中的信息）为 nil 或列表），则它使用对话框或弹出菜单显示消息。  否则，它使用回声区域。  （这与 y-or-np 用于做出类似决定的标准相同；请参阅是或否查询。）

     您可以通过将 last-nonmenu-event 绑定到调用周围的合适值来强制使用鼠标或回显区域。

 功能：消息框格式字符串 &rest 参数 ¶

     此函数显示类似消息的消息，但尽可能使用对话框（或弹出菜单）。  如果由于终端不支持而无法使用对话框或弹出菜单，则 message-box 使用回显区域，如 message。

 功能：display-message-or-buffer message &optional buffer-name action frame ¶

     此函数显示消息消息，它可以是字符串或缓冲区。  如果它小于由 max-mini-window-height 定义的回波区域的最大高度，则使用消息将其显示在回波区域中。  否则，显示缓冲区用于在弹出缓冲区中显示它。

     返回显示在回显区域中的字符串，或者在使用弹出缓冲区时返回用于显示它的窗口。

     如果 message 是字符串，则可选参数 buffer-name 是使用弹出缓冲区时用于显示它的缓冲区的名称，默认为 *Message*。  在message是字符串并显示在回显区的情况下，不指定是否将内容插入缓冲区。

     可选参数 action 和 frame 与 display-buffer 相同，仅在显示缓冲区时使用。

 功能：当前消息¶

     此函数返回当前显示在回显区域中的消息，如果没有则返回 nil。

*** TODO 40.4.2 上报操作进度

当操作可能需要一段时间才能完成时，您应该通知用户它所取得的进展。  这样用户可以估计剩余时间并清楚地看到 Emacs 正忙于工作，而不是挂起。  一种方便的方法是使用进度报告器。

 这是一个没有任何用处的工作示例：

 (let ((progress-reporter)
	（make-progress-reporter “为 Emacs 收集法力...”
				0 500)))
   (dotimes (k 500)
     （静坐 0.01）
     (进度报告者更新进度报告者 k))
   （进度报告者完成进度报告者））

 功能：make-progress-reporter message &optional min-value max-value current-value min-change min-time ¶

     此函数创建并返回一个进度报告器对象，您将使用它作为下面列出的其他函数的参数。  这个想法是预先计算尽可能多的数据，以便非常快速地报告进度。

     当后续使用此进度报告器时，它将在回显区域显示消息，然后显示进度百分比。  message 被视为一个简单的字符串。  例如，如果您需要它依赖于文件名，请在调用此函数之前使用 format-message。

     参数 min-value 和 max-value 应该是代表操作的开始和最终状态的数字。  例如，扫描缓冲区的操作应该将这些设置为相应的 point-min 和 point-max 的结果。  最大值应该大于最小值。

     或者，您可以将 min-value 和 max-value 设置为 nil。  在这种情况下，进度报告者不会报告进程百分比；  相反，它会显示一个“微调器”，每次更新进度报告器时都会旋转一个刻度。

     如果 min-value 和 max-value 是数字，您可以给参数 current-value 一个数值，指定初始进度；  如果省略，则默认为最小值。

     其余参数控制回声区域更新的速率。  在打印下一条消息之前，进度报告者将等待至少 min-change more percents 的操作完成；  默认值为百分之一。  min-time 指定连续打印之间通过的最短时间（以秒为单位）；  默认值为 0.2 秒。  （在某些操作系统上，进度报告器可能会以不同的精度处理几分之一秒）。

     这个函数调用progress-reporter-update，所以第一条消息被立即打印出来。

 功能：progress-reporter-update 报告者&可选值后缀¶

     此功能主要负责报告您的操作进度。  它显示报告者的消息，后跟由值确定的进度百分比。  如果百分比为零，或者根据 min-change 和 min-time 参数足够接近，则从输出中省略它。

     Reporter 必须是调用 make-progress-reporter 的结果。  value 指定您的操作的当前状态，并且必须在传递给 make-progress-reporter 的 min-value 和 max-value（包括）之间。  例如，如果您扫描缓冲区，则 value 应该是调用点的结果。

     可选参数后缀是要在记者的主要消息和进度文本之后显示的字符串。  如果reporter 是一个非数值型的reporter，那么value 应该是nil，或者是一个字符串来代替suffix。

     此函数尊重传递给 make-progress-reporter 的 min-change 和 min-time ，因此不会在每次调用时输出新消息。  因此它非常快，通常您不应尝试减少对其的调用次数：由此产生的开销很可能会抵消您的努力。

 功能：progress-reporter-force-update 报告者&可选值new-message suffix ¶

     这个函数类似于progress-reporter-update，只是它在回显区域无条件地打印一条消息。

     Reporter、value 和 suffix 与 progress-reporter-update 的含义相同。  可选的新消息允许您更改报告者的消息。  由于此功能始终更新回波区域，因此此类更改将立即呈现给用户。

 功能：progress-reporter-done 报告 ¶

     操作完成时应调用此函数。  它在回声区域打印记者的消息，然后是“完成”一词。

     您应该始终调用此函数，而不是希望 progress-reporter-update 打印 '100%'。  首先，它可能永远不会打印出来，这有很多很好的理由不会发生。  其次，“完成”更加明确。

 宏：dotimes-with-progress-reporter（var count [result]）reporter-or-message body… ¶

     这是一个便利宏，其工作方式与 dotimes 相同，但也使用上述函数报告循环进度。  它可以让你节省一些打字。  参数报告器或消息可以是字符串或进度报告器对象。

     您可以使用此宏重写本小节开头的示例，如下所示：

     （dotimes-with-progress-reporter
	 (k 500)
	 “为 Emacs 收集一些魔法值……”
       (静坐 0.01))

     如果要在 make-progress-reporter 中指定可选参数，则使用报告器对象作为报告器或消息参数很有用。  例如，您可以将前面的示例编写如下：

     （dotimes-with-progress-reporter
	 (k 500)
	 （make-progress-reporter “为 Emacs 收集一些魔法值......” 0 500 0 1 1.5）
       (静坐 0.01))

 宏：dolist-with-progress-reporter（var count [result]）reporter-or-message body… ¶

     这是另一个便利宏，其工作方式与 dolist 相同，但也使用上述函数报告循环进度。  与 dotimes-with-progress-reporter 一样，reporter-or-message 可以是进度报告器或字符串。  您可以使用此宏重写前面的示例，如下所示：

     （dolist-with-progress-reporter
	 (k (数字序列 0 500))
	 “为 Emacs 收集一些魔法值……”
       (静坐 0.01))

*** TODO 40.4.3 记录消息 *留言*

几乎所有显示在回显区域的消息也都记录在 *Messages* 缓冲区中，以便用户可以参考它们。  这包括与 message 一起输出的所有消息。  默认情况下，这个缓冲区是只读的并且使用主要模式messages-buffer-mode。  没有什么可以阻止用户杀死 *Messages* 缓冲区，但下一次显示的消息会重新创建它。  任何需要直接访问 *Messages* 缓冲区并希望确保它存在的 Lisp 代码都应该使用函数消息缓冲区。

 功能：消息缓冲区¶

     此函数返回 *Messages* 缓冲区。  如果它不存在，它会创建它，并将其切换到消息缓冲区模式。

 用户选项：message-log-max ¶

     此变量指定在 *Messages* 缓冲区中保留多少行。  值 t 表示保留多少行没有限制。  值 nil 完全禁用消息记录。  以下是显示消息并防止其被记录的方法：

     （让（消息日志最大值）
       （信息 …））

 为了使 *Messages* 对用户更方便，日志记录工具结合了连续的相同消息。  为了两种情况，它还结合了连续的相关消息：问题后接答案，以及一系列进度消息。

 一个问题后面跟着一个答案有两条消息，就像 y-or-np 产生的那样：第一个是“问题”，第二个是“问题...答案”。  除了第二条消息之外，第一条消息没有传达任何其他信息，因此记录第二条消息会丢弃日志中的第一条消息。

 一系列进度消息具有连续的消息，例如由 make-progress-reporter 生成的消息。  它们具有“base...how-far”的形式，其中 base 每次都相同，而 how-far 则不同。  记录系列中的每条消息都会丢弃前一条，前提是它们是连续的。

 函数 make-progress-reporter 和 y-or-np 无需执行任何特殊操作即可激活消息日志组合功能。  每当记录两个连续的消息，它们共享一个以“...”结尾的公共前缀时，它就会运行。

*** TODO 40.4.4 回声区自定义

这些变量控制回声区域如何工作的细节。

 变量：光标在回声区域 ¶

     此变量控制在回显区域中显示消息时光标出现的位置。  如果它不为零，则光标出现在消息的末尾。  否则，光标会出现在点上——根本不在回波区域。

     该值通常为零；  Lisp 程序在短时间内将它绑定到 t。

 变量：echo-area-clear-hook ¶

     每当回显区域被清除时，这个正常的钩子就会运行——无论是通过（消息 nil）还是出于任何其他原因。

 用户选项：回声击键¶

     此变量确定在命令字符回显之前应该经过多少时间。  它的值必须是一个数字，并指定回显前等待的秒数。  如果用户键入前缀键（例如 Cx），然后在继续之前延迟了这么多秒，则前缀键会在回显区域中回显。  （一旦在键序列中开始回显，同一键序列中的所有后续字符都会立即回显。）

     如果该值为零，则不回显命令输入。

 变量：消息截断行¶

     通常，显示长消息会调整回显区域的大小以显示整个消息，并根据需要换行。  但是，如果变量 message-truncate-lines 不为零，则会截断长行的 echo-area 消息以适应迷你窗口的宽度。

 变量 max-mini-window-height 指定调整 minibuffer 窗口大小的最大高度，也适用于 echo 区域（这实际上是 minibuffer 窗口的特殊用途；请参阅 Minibuffer Windows）。

** TODO 40.5 报告警告

警告是程序通知用户可能出现的问题但继续运行的一种工具。


*** TODO 40.5.1 警告基础

每个警告都有一个文本消息，它为用户解释问题，以及一个严重级别，它是一个符号。  以下是可能的严重性级别，按严重性降序排列，以及它们的含义：

 ：紧急情况

     如果您不及时处理，很快就会严重影响 Emacs 操作的问题。
 ：错误

     本质上错误的数据或情况的报告。
 ：警告

     报告本质上不是错误的数据或情况，但会引起对可能问题的怀疑。
 :调试

     如果您正在调试，可能会有用的信息报告。

 当你的程序遇到无效的输入数据时，它可以通过调用 error 或 signal 来表示 Lisp 错误，或者报告严重性为 :error 的警告。  发出 Lisp 错误信号是最简单的事情，但这意味着程序无法继续处理。  如果您想不厌其烦地实施一种方法来继续处理不良数据，那么报告严重性警告 :error 是通知用户问题的正确方法。  例如，Emacs Lisp 字节编译器可以通过这种方式报告错误并继续编译其他函数。  （如果程序发出 Lisp 错误信号，然后用条件情况处理它，用户将看不到错误消息；它可以通过将消息报告为警告来向用户显示该消息。）

 每个警告都有一个警告类型来对其进行分类。  类型是符号列表。  第一个符号应该是您用于程序用户选项的自定义组。  例如，字节编译器警告使用警告类型 (bytecomp)。  如果您愿意，您还可以通过在列表中使用更多符号对警告进行子分类。

 功能：显示警告类型消息&可选级别缓冲区名称¶

     此函数上报警告，使用 message 作为消息，使用 type 作为警告类型。  level 应该是严重级别， :warning 是默认值。

     buffer-name，如果非零，则指定用于记录警告的缓冲区的名称。  默认情况下，它是*警告*。

 功能：lwarn 类型级消息 &rest args ¶

     此函数使用 (format-message message args...) 的值作为 *Warnings* 缓冲区中的消息报告警告。  在其他方面，它相当于显示警告。

 功能：警告信息 &rest args ¶

     此函数使用 (format-message message args...) 的值作为消息，(emacs) 作为类型，使用 :warning 作为严重级别来报告警告。  它的存在只是为了兼容；  我们建议不要使用它，因为您应该指定特定的警告类型。

*** TODO 40.5.2 警告变量

程序可以通过绑定本节中描述的变量来自定义其警告的显示方式。

 变量：警告级别¶

     此列表定义警告严重性级别的含义和严重性顺序。  每个元素定义一个严重性级别，它们按严重性降序排列。

     每个元素都有形式（级别字符串函数），其中级别是它定义的严重级别。  字符串指定此级别的文本描述。  string 应该使用 '%s' 来指定放置警告类型信息的位置，或者它可以省略 '%s' 以便不包含该信息。

     可选函数，如果非零，是一个不带参数调用的函数，以引起用户的注意。

     通常不应更改此变量的值。

 变量：警告前缀函数¶

     如果非零，则该值是为警告生成前缀文本的函数。  程序可以将变量绑定到合适的函数。  display-warning 使用警告缓冲区当前调用此函数，该函数可以在其中插入文本。  该文本成为警告消息的开头。

     该函数使用两个参数调用，即严重性级别及其在警告级别中的条目。  它应该返回一个列表以用作条目（此值不必是警告级别的实际成员）。  通过构造此值，函数可以更改警告的严重性，或为给定的严重性级别指定不同的处理。

     如果变量的值为 nil 则没有函数可以调用。

 变量：警告系列¶

     程序可以将此变量绑定到 t 以表示下一个警告应该开始一个系列。  当多个警告形成一个系列时，这意味着在系列的第一个警告上留下点，而不是为每个警告继续移动它，以便它出现在最后一个警告上。  当本地绑定解除绑定并且warning-series 再次变为nil 时，该系列结束。

     该值也可以是具有函数定义的符号。  这等效于 t，除了下一个警告还将调用没有参数且警告缓冲区当前的函数。  该函数可以插入文本，作为一系列警告的标题。

     一旦系列开始，该值就是一个标记，它指向系列开始的警告缓冲区中的缓冲区位置。

     该变量的正常值为 nil，这意味着分别处理每个警告。

 变量：警告填充前缀¶

     当此变量为非零时，它指定用于填充每个警告文本的填充前缀。

 变量：警告填充列¶

     填写警告的列。

 变量：警告类型格式¶

     此变量指定在警告消息中显示警告类型的格式。  以这种方式格式化类型的结果将包含在消息中，由警告级别条目中的字符串控制。  默认值为“ (%s)”。  如果将其绑定到“”，则根本不会出现警告类型。

*** TODO 40.5.3 警告选项

用户使用这些变量来控制 Lisp 程序报告警告时发生的情况。

 用户选项：警告最低级别 ¶

     此用户选项指定应立即向用户显示的最低严重性级别。  默认为 :warning，即立即显示除 :debug 警告之外的所有警告。

 用户选项：警告最小日志级别¶

     此用户选项指定应记录在警告缓冲区中的最低严重级别。  默认值为 :warning，表示记录除 :debug 警告之外的所有警告。

 用户选项：警告抑制类型¶

     此列表指定不应立即向用户显示哪些警告类型。  列表的每个元素都应该是一个符号列表。  如果其元素与警告类型中的第一个元素匹配，则不会立即显示该警告。

 用户选项：警告抑制日志类型¶

     此列表指定不应将哪些警告类型记录在警告缓冲区中。  列表的每个元素都应该是一个符号列表。  如果它与警告类型中的前几个元素匹配，则不会记录该警告。

*** TODO 40.5.4 延迟警告

有时，您可能希望避免在命令运行时显示警告，仅在命令结束后显示。  您可以为此使用功能延迟警告。

 功能：延迟警告类型消息&可选级别缓冲区名称¶

     此函数是显示警告的延迟对应物（请参阅警告基础知识），并且使用相同的参数调用它。  警告消息排队到延迟警告列表中。

 变量：延迟警告列表¶

     此变量的值是当前命令完成后要显示的警告列表。  每个元素必须是一个列表

     （类型消息 [级别 [缓冲区名称]]）

     与显示警告的参数列表形式相同，含义相同。  运行 post-command-hook（请参阅命令循环概述）后，Emacs 命令循环立即显示此变量指定的所有警告，然后将其重置为 nil。

 需要进一步自定义延迟警告机制的程序可以更改变量delayed-warnings-hook：

 变量：延迟警告挂钩¶

     这是一个普通的钩子，由 Emacs 命令循环在 post-command-hook 之后运行，以处理和显示延迟警告。

     它的默认值是两个函数的列表：

     （折叠延迟警告显示延迟警告）

     函数 collapse-delayed-warnings 从延迟警告列表中删除重复的条目。  函数 display-delayed-warnings 依次对 delay-warnings-list 中的每个条目调用 display-warning，然后将 delay-warnings-list 设置为 nil。

** TODO 40.6 不可见文本

您可以使用 invisible 属性使字符不可见，以便它们不会出现在屏幕上。  这可以是文本属性（请参阅文本属性）或覆盖属性（请参阅覆盖）。  光标运动也部分忽略了这些字符；  如果命令循环在命令后发现该点位于不可见文本范围内，则它将点重新定位到文本的另一侧。

 在最简单的情况下，任何非 nil 不可见属性都会使字符不可见。  这是默认情况——如果你不改变 buffer-invisibility-spec 的默认值，这就是 invisible 属性的工作方式。  如果您不打算自己设置 buffer-invisibility-spec，通常应该使用 t 作为 invisible 属性的值。

 更一般地，您可以使用变量 buffer-invisibility-spec 来控制不可见属性的哪些值使文本不可见。  这允许您预先将文本分类为不同的子集，通过赋予它们不同的不可见值，然后通过更改 buffer-invisibility-spec 的值使各种子集可见或不可见。

 使用 buffer-invisibility-spec 控制可见性在显示数据库中条目列表的程序中特别有用。  它允许执行方便的过滤命令来查看数据库中的部分条目。  设置此变量非常快，比扫描缓冲区中的所有文本以查找要更改的属性要快得多。

 变量：buffer-invisibility-spec ¶

     此变量指定哪些类型的不可见属性实际上使字符不可见。  设置此变量使其成为缓冲区本地。

     吨

	 如果一个字符的 invisible 属性为非 nil，则该字符是不可见的。  这是默认设置。
     一个列表

	 列表的每个元素都指定了不可见的标准；  如果角色的隐形属性符合这些条件中的任何一项，则该角色是隐形的。  列表可以有两种元素：

	 原子

	     如果一个字符的不可见属性值是 atom 或者它是一个以 atom 作为成员的列表，则该字符是不可见的；  比较是用eq完成的。
	 （原子.t）

	     如果一个字符的不可见属性值是 atom 或者它是一个以 atom 作为成员的列表，则该字符是不可见的；  比较是用eq完成的。  此外，这些字符的序列显示为省略号。

 专门提供了两个函数来向 buffer-invisibility-spec 添加元素和从中删除元素。

 功能：添加到不可见性规范元素¶

     此函数将元素元素添加到 buffer-invisibility-spec。  如果 buffer-invisibility-spec 是 t，它会变成一个列表 (t)，因此不可见属性为 t 的文本保持不可见。

 功能：从不可见规范中移除元素¶

     这会从 buffer-invisibility-spec 中删除元素元素。  如果元素不在列表中，则此操作无效。

 使用 buffer-invisibility-spec 的约定是主要模式应该使用模式自己的名称作为 buffer-invisibility-spec 的元素和 invisible 属性的值：

 ;;  如果要显示省略号：
 (add-to-invisibility-spec '(my-symbol . t))
 ;;  如果你不想要省略号：
 （添加到不可见性规范“我的符号”）

 (overlay-put (make-overlay 开始结束)
	      '隐形'我的符号）

 ;;  完成隐形后：
 (remove-from-invisibility-spec '(my-symbol . t))
 ;;  或分别：
 （从隐形规范中删除“我的符号”）

 您可以使用以下功能检查隐身性：

 功能：invisible-p pos-or-prop ¶

     如果 pos-or-prop 是标记或数字，如果该位置的文本当前不可见，则此函数返回非零值。

     如果 pos-or-prop 是任何其他类型的 Lisp 对象，则表示不可见文本或覆盖属性的可能值。  在这种情况下，如果该值会导致文本变得不可见，则此函数将根据 buffer-invisibility-spec 的当前值返回一个非零值。

     如果文本将在显示时完全隐藏，则此函数的返回值为 t，如果文本将被省略号替换，则返回非零、非 t 值。

 通常，对文本或移动点进行操作的函数并不关心文本是否不可见，它们处理不可见字符和可见字符一样。  如果 line-move-ignore-invisible 为非 nil（默认值），则用户级别的行移动命令，例如 next-line、previous-line，将忽略不可见的换行符，即表现得就像这些不可见的换行符在缓冲区，但仅仅是因为它们被明确编程为这样做。

 如果命令以不可见文本内部或边界处的点结束，则主编辑循环将点重新定位到不可见文本的两端之一。  Emacs 选择重定位的方向，使其与命令的整体移动方向一致；  如果有疑问，它更喜欢插入的字符不会继承不可见属性的位置。  此外，如果文本没有被省略号替换并且命令仅在不可见文本内移动，则将点移动一个额外的字符，以便尝试通过光标的可见移动来反映命令的移动。

 因此，如果命令将点移回不可见范围（具有通常的粘性），Emacs 会将点移回该范围的开头。  如果命令将点向前移动到不可见范围内，Emacs 会将点向前移动到不可见文本后面的第一个可见字符，然后再向前移动一个字符。

 可以通过将 disable-point-adjustment 设置为非零值来禁用这些在不可见文本中间结束的点的调整。  请参阅命令后调整点。

 当匹配包含不可见文本时，增量搜索可以使不可见覆盖暂时和/或永久可见。  要启用此功能，叠加层应具有非零 isearch-open-invisible 属性。  属性值应该是一个以叠加层作为参数调用的函数。  此功能应使叠加层永久可见；  当匹配与退出搜索时的覆盖重叠时使用它。

 在搜索过程中，通过临时修改它们的不可见和无形属性，使此类叠加层临时可见。  如果您希望对某个叠加层以不同的方式执行此操作，请给它一个 isearch-open-invisible-temporary 属性，它是一个函数。  该函数使用两个参数调用：第一个是叠加层，第二个是 nil 使叠加层可见，或 t 使其再次不可见。

** TODO 40.7 选择性显示

选择性显示是指在屏幕上隐藏某些行的一对相关功能。

 第一个变体，显式选择性显示，设计用于 Lisp 程序：它通过更改文本来控制隐藏哪些行。  这种隐藏现在已经过时和弃用了；  相反，您应该使用不可见属性（请参阅不可见文本）来获得相同的效果。

 在第二个变体中，根据缩进自动选择要隐藏的行。  此变体旨在成为用户级功能。

 控制显式选择性显示的方法是将换行符 (control-j) 替换为回车符 (control-m)。  以前是该换行符之后的一行的文本现在被隐藏了。  严格来说，它暂时不再是一行，因为只有换行才能分隔行；  它现在是前一行的一部分。

 选择性显示不直接影响编辑命令。  例如，Cf (forward-char) 毫不犹豫地将点移动到隐藏文本中。  但是，用回车符替换换行符会影响一些编辑命令。  例如，下一行跳过隐藏行，因为它只搜索换行符。  使用选择性显示的模式还可以定义考虑换行符的命令，或者控制隐藏文本的哪些部分。

 当您将选择性显示的缓冲区写入文件时，所有 control-m 都作为换行符输出。  这意味着当您下次读取文件时，它看起来还不错，没有任何隐藏。  选择性显示效果仅在 Emacs 中可见。

 变量：选择性显示¶

     此缓冲区局部变量启用选择性显示。  这意味着可以隐藏线条或线条的一部分。

	 如果selective-display的值为t，则字符control-m标记隐藏文本的开始；  不显示 control-m 及其后的其余行。  这是明确的选择性显示。
	 如果selective-display 的值是一个正整数，则不显示以多于那么多缩进列开始的行。

     当缓冲区的某些部分被隐藏时，垂直移动命令就像该部分不存在一样运行，从而允许单个下一行命令跳过任意数量的隐藏行。  但是，字符移动命令（例如 forward-char）不会跳过隐藏部分，并且可以（如果棘手）在隐藏部分中插入或删除文本。

     在下面的例子中，我们展示了缓冲区 foo 的显示外观，它随着选择性显示的值而变化。  缓冲区的内容不会改变。

     (setq 选择性显示 nil)
	  ⇒ 无

     ---------- 缓冲区： foo ----------
     1 在此列
      2在本栏目
       3n 本栏目
       3n 本栏目
      2在本栏目
     1 在此列
     ---------- 缓冲区： foo ----------


     (setq 选择性显示 2)
	  ⇒ 2

     ---------- 缓冲区： foo ----------
     1 在此列
      2在本栏目
      2在本栏目
     1 在此列
     ---------- 缓冲区： foo ----------

 用户选项：选择性显示椭圆¶

     如果这个缓冲区局部变量不为 nil，那么 Emacs 会在行尾显示“...”，然后是隐藏文本。  这个例子是前一个例子的延续。

     (setq 选择性显示椭圆 t)
	  ⇒ 吨

     ---------- 缓冲区： foo ----------
     1 在此列
      2在这个专栏...
      2在本栏目
     1 在此列
     ---------- 缓冲区： foo ----------

     您可以使用显示表来替换省略号 ('...') 的其他文本。  请参阅显示表格。

** TODO 40.8 临时展示

Lisp 程序使用临时显示将输出放入缓冲区，然后将其呈现给用户阅读而不是编辑。  许多帮助命令使用此功能。

 宏：with-output-to-temp-buffer buffer-name body… ¶

     该函数执行 body 中的表单，同时安排将它们打印的任何输出插入名为 buffer-name 的缓冲区中，如果需要，首先创建该缓冲区，然后进入帮助模式。  （参见下面与-temp-buffer-window 类似的表格。）最后，缓冲区显示在某个窗口中，但该窗口未被选中。

     如果 body 中的表单没有改变输出缓冲区中的主要模式，因此在它们执行结束时它仍然是帮助模式，那么 with-output-to-temp-buffer 使这个缓冲区在最后是只读的，并且还扫描它以查找函数和变量名称，以使它们成为可点击的交叉引用。  有关详细信息，请参阅文档字符串提示，特别是文档字符串中的超链接项目。

     字符串 buffer-name 指定临时缓冲区，它不需要已经存在。  参数必须是字符串，而不是缓冲区。  缓冲区最初被擦除（不询问任何问题），并在 with-output-to-temp-buffer 退出后标记为未修改。

     with-output-to-temp-buffer 将标准输出绑定到临时缓冲区，然后评估正文中的表单。  默认情况下，使用正文中的 Lisp 输出函数输出到该缓冲区（但回显区域中的屏幕显示和消息，虽然它们是一般意义上的“输出”，但不受影响）。  请参阅输出函数。

     有几个钩子可用于自定义此构造的行为；  它们在下面列出。

     返回正文中最后一个表单的值。

     ---------- 缓冲区： foo ----------
      这是 foo 的内容。
     ---------- 缓冲区： foo ----------


     （带有输出到临时缓冲区“foo”
	 （打印 20）
	 （打印标准输出））
     ⇒ #<buffer foo>

     ---------- 缓冲区： foo ----------

     20

     #<缓冲区 foo>

     ---------- 缓冲区： foo ----------

 用户选项：temp-buffer-show-function ¶

     如果此变量不为零，with-output-to-temp-buffer 将其作为函数调用以完成显示帮助缓冲区的工作。  该函数有一个参数，即它应该显示的缓冲区。

     最好让这个函数像 with-output-to-temp-buffer 一样运行 temp-buffer-show-hook，在 save-selected-window 内并选择选定的窗口和缓冲区。

 变量：temp-buffer-setup-hook ¶

     这个正常的钩子在评估 body 之前由 with-output-to-temp-buffer 运行。  当钩子运行时，临时缓冲区是当前的。  这个钩子通常设置了一个函数来将缓冲区置于帮助模式。

 变量：temp-buffer-show-hook ¶

     这个普通的钩子在显示临时缓冲区后由 with-output-to-temp-buffer 运行。  当钩子运行时，临时缓冲区是当前的，并且显示它的窗口被选中。

 宏：with-temp-buffer-window buffer-or-name action quit-function body… ¶

     此宏类似于 with-output-to-temp-buffer。  与该构造类似，它在安排将其打印的任何输出插入名为 buffer-or-name 的缓冲区并在某个窗口中显示该缓冲区的同时执行主体。  但是，与 with-output-to-temp-buffer 不同，它不会自动将该缓冲区切换到帮助模式。

     参数 buffer-or-name 指定临时缓冲区。  它可以是一个必须已经存在的缓冲区，也可以是一个字符串，在这种情况下，如有必要，将创建一个具有该名称的缓冲区。  当 with-temp-buffer-window 退出时，缓冲区被标记为未修改和只读。

     此宏不调用 temp-buffer-show-function。  相反，它将 action 参数传递给 display-buffer（请参阅选择用于显示缓冲区的窗口）以显示缓冲区。

     除非指定了参数 quit-function，否则返回 body 中最后一个表单的值。  在这种情况下，使用两个参数调用它：显示缓冲区的窗口和正文的结果。  最终的返回值就是退出函数返回的值。

     这个宏使用普通的钩子 temp-buffer-window-setup-hook 和 temp-buffer-window-show-hook 来代替 with-output-to-temp-buffer 运行的类似钩子。

 接下来描述的两个结构与 with-temp-buffer-window 基本相同，但与指定的不同：

 宏：with-current-buffer-window buffer-or-name action quit-function &rest body ¶

     这个宏类似于 with-temp-buffer-window 但不同的是，它使由 buffer-or-name 指定的缓冲区当前用于运行主体。

 显示临时缓冲区的窗口可以使用以下模式适合该缓冲区的大小：

 用户选项：temp-buffer-resize-mode ¶

     启用此次要模式时，显示临时缓冲区的窗口会自动调整大小以适应其缓冲区的内容。

     当且仅当它是专门为缓冲区创建的时，才会调整窗口的大小。  特别是，以前显示过另一个缓冲区的窗口不会调整大小。  默认情况下，此模式使用 fit-window-to-buffer（请参阅调整窗口大小）来调整大小。  您可以通过自定义以下选项 temp-buffer-max-height 和 temp-buffer-max-width 来指定不同的函数。

 用户选项：temp-buffer-max-height ¶

     此选项指定启用 temp-buffer-resize-mode 时显示临时缓冲区的窗口的最大高度（以行为单位）。  它也可以是一个被调用来选择这样一个缓冲区的高度的函数。  它有一个参数，缓冲区，并且应该返回一个正整数。  在调用函数时，选择要调整大小的窗口。

 用户选项：temp-buffer-max-width ¶

     此选项指定启用 temp-buffer-resize-mode 时显示临时缓冲区的窗口的最大宽度（以列为单位）。  它也可以是一个被调用来选择这样一个缓冲区的宽度的函数。  它有一个参数，缓冲区，并且应该返回一个正整数。  在调用函数时，选择要调整大小的窗口。

 以下函数使用当前缓冲区进行临时显示：

 功能：瞬时字符串显示字符串位置&可选字符消息¶

     此函数会在当前缓冲区的位置暂时显示字符串。  它对撤消列表或缓冲区的修改状态没有影响。

     瞬时显示一直保持到下一个输入事件。  如果下一个输入事件是 char，则 momentary-string-display 会忽略它并返回。  否则，该事件将保持缓冲以供后续用作输入。  因此，键入 char 将简单地从显示中删除字符串，而键入（例如）Cf 将从显示中删除字符串，然后（可能）向前移动点。  默认情况下，参数 char 是一个空格。

     momentary-string-display 的返回值没有意义。

     如果字符串 string 不包含控制字符，您可以通过创建（然后删除）具有 before-string 属性的覆盖以更通用的方式完成相同的工作。  请参见叠加属性。

     如果 message 不为 nil，则显示在 echo 区域中，而 string 显示在缓冲区中。  如果它是 nil，则默认消息说键入 char 以继续。

     在此示例中，点最初位于第二行的开头：

     ---------- 缓冲区： foo ----------
     这是 foo 的内容。
     *第二行。
     ---------- 缓冲区： foo ----------


     （瞬时字符串显示
       “**** 重要讯息！ ****”
       （点）？\r
       “完成阅读后键入 RET”）
     ⇒ 吨


     ---------- 缓冲区： foo ----------
     这是 foo 的内容。
     **** 重要讯息！  ****第二行。
     ---------- 缓冲区： foo ----------

     ---------- 回声区 ----------
     读完后输入 RET
     ---------- 回声区 ----------

** TODO 40.9 叠加

为了演示功能，您可以使用覆盖来改变屏幕上缓冲区文本的外观。  覆盖是属于特定缓冲区的对象，具有指定的开始和结束。  它还具有您可以检查和设置的属性；  这些会影响叠加层中文本的显示。

 叠加层的视觉效果与相应的文本属性相同（请参阅文本属性）。  然而，由于不同的实现，覆盖通常不能很好地扩展（许多操作所花费的时间与缓冲区中的覆盖数量成正比）。  如果您需要影响缓冲区中许多部分的视觉外观，我们建议使用文本属性。

 覆盖使用标记来记录它的开始和结束；  因此，编辑缓冲区的文本会调整每个叠加层的开头和结尾，使其与文本保持一致。  创建叠加层时，您可以指定在开头插入的文本应该在叠加层内部还是外部，同样用于叠加层的末尾。

*** TODO 40.9.1 管理覆盖

本节介绍创建、删除和移动覆盖以及检查其内容的功能。  覆盖更改不会记录在缓冲区的撤消列表中，因为覆盖不是缓冲区内容的一部分。

 功能：覆盖对象¶

     如果对象是叠加层，则此函数返回 t。

 功能：make-overlay start end & optional buffer front-advance rear-advance ¶

     此函数创建并返回属于缓冲区且范围从开始到结束的覆盖。  start 和 end 都必须指定缓冲区位置；  它们可能是整数或标记。  如果省略缓冲区，则在当前缓冲区中创建覆盖。

     开始和结束指定相同缓冲区位置的覆盖称为空。  如果删除了开头和结尾之间的文本，则非空叠加层可能会变为空。  发生这种情况时，默认情况下不会删除覆盖，但您可以通过赋予其“蒸发”属性（请参阅蒸发属性）将其删除。

     参数front-advance 和rear-advance 分别指定覆盖开始和覆盖结束的标记插入类型。  请参阅标记插入类型。  如果它们都是 nil（默认值），则覆盖将扩展到包括在开头插入的任何文本，但不包括在末尾插入的文本。  如果 front-advance 不为零，则插入在覆盖开头的文本将从覆盖中排除。  如果 back-advance 不为零，则插入到覆盖层末尾的文本将包含在覆盖层中。

 功能：覆盖开始覆盖¶

     此函数以整数形式返回覆盖开始的位置。

 功能：overlay-end 叠加¶

     此函数以整数形式返回覆盖结束的位置。

 功能：覆盖缓冲区覆盖¶

     该函数返回叠加层所属的缓冲区。  如果覆盖已被删除，则返回 nil。

 功能：删除覆盖覆盖¶

     此功能删除覆盖。  叠加层继续作为 Lisp 对象存在，它的属性列表没有改变，但它不再附加到它所属的缓冲区，并且不再对显示产生任何影响。

     已删除的叠加层不会永久断开连接。  您可以通过调用 move-overlay 再次给它在缓冲区中的位置。

 功能：move-overlay 覆盖开始结束&可选缓冲区 ¶

     此函数将覆盖移动到缓冲区，并将其边界放置在开始和结束处。  参数 start 和 end 都必须指定缓冲区位置；  它们可能是整数或标记。

     如果 buffer 被省略，overlay 将停留在它已经关联的同一个缓冲区中；  如果覆盖被删除，它会进入当前缓冲区。

     返回值是覆盖。

     这是更改覆盖的端点的唯一有效方法。  不要尝试手动修改叠加层中的标记，因为这无法更新其他重要数据结构并可能导致一些叠加层丢失。

 功能：remove-overlays &optional start end name value ¶

     此函数删除属性名称具有值 value 的 start 和 end 之间的所有覆盖。  它可以移动区域中叠加层的端点，或拆分它们。

     如果 name 省略或为 nil，则表示删除指定区域内的所有叠加层。  如果 start 和/或 end 被省略或为零，则分别表示缓冲区的开始和结束。  因此， (remove-overlays) 删除当前缓冲区中的所有覆盖。

 功能：复制叠加 ¶

     此函数返回覆盖的副本。  副本具有与覆盖相同的端点和属性。  但是，覆盖开始和覆盖结束的标记插入类型设置为其默认值（请参阅标记插入类型）。

 这里有些例子：

 ;;  创建叠加层。
 (setq foo (make-overlay 1 10))
      ⇒ #<display.texi 中从 1 到 10 的覆盖>
 （覆盖开始 foo）
      ⇒ 1
 （覆盖端 foo）
      ⇒ 10
 （覆盖缓冲区 foo）
      ⇒ #<缓冲区显示.texi>
 ;;  给它一个我们可以稍后检查的属性。
 (overlay-put foo 'happy t)
      ⇒ 吨
 ;;  验证属性是否存在。
 (overlay-get foo '快乐)
      ⇒ 吨
 ;;  移动覆盖。
 （移动覆盖 foo 5 20）
      ⇒ #<display.texi 中从 5 到 20 的叠加层>
 （覆盖开始 foo）
      ⇒ 5
 （覆盖端 foo）
      ⇒ 20
 ;;  删除覆盖。
 （删除覆盖 foo）
      ⇒ 无
 ;;  确认已删除。
 富
      ⇒ #<无缓冲区覆盖>
 ;;  已删除的叠加层没有位置。
 （覆盖开始 foo）
      ⇒ 无
 （覆盖端 foo）
      ⇒ 无
 （覆盖缓冲区 foo）
      ⇒ 无
 ;;  取消删除覆盖。
 （移动覆盖 foo 1 20）
      ⇒ #<display.texi 中从 1 到 20 的覆盖>
 ;;  验证结果。
 （覆盖开始 foo）
      ⇒ 1
 （覆盖端 foo）
      ⇒ 20
 （覆盖缓冲区 foo）
      ⇒ #<缓冲区显示.texi>
 ;;  移动和删除覆盖不会更改其属性。
 (overlay-get foo '快乐)
      ⇒ 吨

 Emacs 将每个缓冲区的覆盖存储在两个列表中，围绕任意中心位置划分。  一个列表从该中心位置向后延伸穿过缓冲区，另一个从该中心位置向前延伸。  中心位置可以在缓冲区中的任何位置。

 功能：overlay-recenter pos ¶

     此函数将当前缓冲区的覆盖集中在位置 pos 周围。  这使得 pos 附近的位置的覆盖查找更快，但远离 pos 的位置更慢。

 如果您先执行 (overlay-recenter (point-max))，则向前扫描缓冲区并创建覆盖的循环可以运行得更快。

*** TODO 40.9.2 覆盖属性

覆盖属性类似于文本属性，因为改变字符显示方式的属性可以来自任一来源。  但在大多数方面，它们是不同的。  请参阅文本属性进行比较。

 文本属性被认为是文本的一部分；  叠加层及其属性被特别认为不是文本的一部分。  因此，在各种缓冲区和字符串之间复制文本会保留文本属性，但不会尝试保留覆盖。  更改缓冲区的文本属性会将缓冲区标记为已修改，而移动覆盖或更改其属性则不会。  与文本属性更改不同，覆盖属性更改不会记录在缓冲区的撤消列表中。

 由于多个叠加层可以为同一个字符指定一个属性值，因此 Emacs 允许您为每个叠加层指定一个优先级值。  优先级值用于决定哪些重叠覆盖将“获胜”。

 这些函数读取和设置覆盖的属性：

 功能：覆盖获取覆盖道具¶

     此函数返回覆盖中记录的属性 prop 的值（如果有）。  如果 overlay 没有记录该属性的任何值，但它确实有一个作为符号的类别属性，则使用该符号的 prop 属性。  否则，该值为 nil。

 功能：overlay-put 叠加道具值 ¶

     该函数将overlay中记录的property prop的值设置为value。  它返回值。

 功能：覆盖属性覆盖¶

     这将返回覆盖属性列表的副本。

 另请参阅函数 get-char-property，它检查给定字符的叠加属性和文本属性。  请参阅检查文本属性。

 许多叠加属性具有特殊含义；  这是他们的表格：

 优先事项 ¶

     该属性的值决定了覆盖的优先级。  如果要指定优先级值，请使用 nil（或零）或正整数。  任何其他值都有未定义的行为。

     当两个或多个覆盖覆盖相同的字符并且都指定相同的属性时，优先级很重要；  优先级值较大的一个会覆盖另一个。  （对于 face 属性，优先级较高的叠加层的值不会完全覆盖另一个值；相反，它的面属性会覆盖较低优先级的面属性的面属性。）如果两个叠加层具有相同的优先级值，并且其中一个嵌套在另一种，那么内在的将胜过外在的。  如果两者都没有嵌套在另一个中，那么您不应该假设哪个覆盖将占上风。

     目前，所有叠加层都优先于文本属性。

     请注意，Emacs 有时会对其某些内部覆盖使用非数字优先级值，因此不要尝试对覆盖的优先级进行算术运算（除非它是您创建的）。  特别是，用于显示区域的覆盖使用表单（primary .secondary）的优先级值，其中primary 值如上所述使用，而secondary 是在primary 和嵌套考虑无法解决问题时使用的备用值覆盖之间的优先级。  但是，建议您不要根据这个实现细节来设计 Lisp 程序；  如果您需要按优先顺序放置叠加层，请使用叠加层-at 的 sorted 参数。  请参阅搜索叠加层。
 窗户 ¶

     如果 window 属性不为 nil，则覆盖仅适用于该窗口。
 类别 ¶

     如果叠加层具有类别属性，我们将其称为叠加层的类别。  它应该是一个符号。  符号的属性用作叠加层属性的默认值。
 脸 ¶

     此属性控制文本的外观（请参阅 Faces）。  该属性的值可以如下：

	 面名（符号或字符串）。
	 匿名面孔：表单的属性列表（关键字值...），其中每个关键字是面孔属性名称，值是该属性的值。
	 面孔列表。  每个列表元素应该是人脸名称或匿名人脸。  这指定了一个面，它是每个列出的面的属性的聚合。  列表中较早出现的面孔具有更高的优先级。
	 形式为 (foreground-color . color-name) 或 (background-color . color-name) 的 cons 单元格。  这指定前景色或背景色，类似于 (:foreground color-name) 或 (:background color-name)。  支持这种形式只是为了向后兼容，应该避免使用。

 鼠标面¶

     当鼠标在覆盖范围内时，使用此属性代替 face。  但是，Emacs 会忽略该属性中所有改变文本大小的人脸属性（例如，:height、:weight 和 :slant）。  这些属性始终与未突出显示的文本中的相同。
 展示 ¶

     该属性激活了改变文本显示方式的各种功能。  例如，它可以使文本显得更高或更短、更高或更低、更宽或更窄，或者替换为图像。  请参阅显示属性。
 帮助回声¶

     如果覆盖具有帮助回显属性，那么当您将鼠标移动到覆盖中的文本上时，Emacs 会在回显区域或工具提示窗口中显示帮助字符串。  有关详细信息，请参阅文本帮助回显。
 场地 ¶

     具有相同字段属性的连续字符构成一个字段。  包括前向字和行首在内的一些运动功能在字段边界处停止移动。  请参阅定义和使用字段。
 修改钩子¶

     这个属性的值是一个函数列表，如果覆盖层中的任何字符被更改或者如果文本被严格地插入到覆盖层中，则该函数将被调用。

     每次更改之前和之后都会调用挂钩函数。  如果函数保存它们收到的信息，并在调用之间比较注释，它们可以准确地确定缓冲区文本中发生了哪些更改。

     在更改之前调用时，每个函数都会接收四个参数：overlay、nil 以及要修改的文本范围的开头和结尾。

     在更改后调用时，每个函数都会接收五个参数：叠加层、t、刚刚修改的文本范围的开始和结束，以及被该范围替换的更改前文本的长度。  （对于插入，更改前的长度为零；对于删除，该长度是删除的字符数，并且更改后的开头和结尾相等。）

     当这些函数被调用时，禁止修改钩子被绑定到非零。  如果函数修改了缓冲区，您可能希望将 inhibitor-modification-hooks 绑定到 nil，以便为这些修改运行更改挂钩。  但是，这样做可能会递归调用您自己的更改挂钩，因此请务必为此做好准备。  请参阅更改挂钩。

     文本属性也支持 modify-hooks 属性，但细节有些不同（请参阅具有特殊含义的属性）。
 插入前钩¶

     此属性的值是在叠加层开头插入文本之前和之后要调用的函数列表。  调用约定与修改钩子函数相同。
 插入挂钩¶

     此属性的值是在叠加层末尾插入文本之前和之后要调用的函数列表。  调用约定与修改钩子函数相同。
 无形的 ¶

     invisible 属性可以使叠加层中的文本不可见，也就是说它不会出现在屏幕上。  有关详细信息，请参阅不可见文本。
 无形的¶

     覆盖上的无形属性就像无形文本属性一样工作。  它已经过时了。  有关详细信息，请参阅具有特殊含义的属性。
 isearch-打开-隐形

     此属性告诉增量搜索如何使不可见的覆盖永久可见，如果最终匹配与其重叠。  请参阅不可见文本。
 isearch-open-invisible-temporary

     此属性告诉增量搜索如何在搜索期间使不可见的覆盖暂时可见。  请参阅不可见文本。
 字符串前 ¶

     此属性的值是要添加到叠加层开头的显示的字符串。  该字符串在任何意义上都不会出现在缓冲区中——只出现在屏幕上。
 字符串后¶

     此属性的值是要添加到叠加层末尾显示的字符串。  该字符串在任何意义上都不会出现在缓冲区中——只出现在屏幕上。
 行前缀

     此属性指定在显示时添加到每个非连续行的显示规范。  请参阅截断。
 换行前缀

     此属性指定在显示时添加到每个续行的显示规范。  请参阅截断。
 蒸发¶

     如果此属性为非零，则如果覆盖为空（即，如果其长度为零），则会自动删除覆盖。  如果你给一个空覆盖（见空覆盖）一个非零的蒸发属性，它会立即删除它。  请注意，除非覆盖具有此属性，否则当从缓冲区中删除其开始位置和结束位置之间的文本时，它不会被删除。
 键盘映射¶

     如果此属性不为 nil，则它为文本的一部分指定一个键映射。  此键映射优先于大多数其他键映射（请参阅活动键映射），并且当点位于覆盖范围内时使用它，其中 front-and-rear-advance 属性定义边界是否被视为在覆盖范围内。
 本地地图¶

     local-map 属性与 keymap 类似，但替换了缓冲区的本地映射，而不是扩充现有的 keymap。  这也意味着它的优先级低于次要模式键映射。

 keymap 和 local-map 属性不会影响由 before-string、after-string 或 display 属性显示的字符串。  这仅与鼠标单击和落在字符串上的其他鼠标事件相关，因为点从不在字符串上。  要为字符串绑定特殊的鼠标事件，请为其分配一个键映射或本地映射文本属性。  请参阅具有特殊含义的属性。

*** TODO 40.9.3 搜索覆盖

功能：overlays-at pos &optional sorted ¶

     此函数返回覆盖当前缓冲区中位置 pos 处的字符的所有叠加层的列表。  如果 sorted 不为零，则列表按优先级降序排列，否则没有特定顺序。  覆盖包含位置 pos，如果它开始于 pos 或在 pos 之前，并在 pos 之后结束。

     为了说明用法，这里有一个 Lisp 函数，它返回一个覆盖层列表，这些覆盖层为点处的字符指定属性 prop：

     (defun find-overlays-specifying (prop)
       (let ((overlays (overlays-at (point))))
	     成立）
	 （而叠加
	   （让（（覆盖（汽车覆盖）））
	     (if (overlay-get overlay prop)
		 (setq found (cons overlay found))))
	   （setq 覆盖（cdr 覆盖）））
	 成立））

 功能：overlays-in beg end ¶

     这个函数返回一个覆盖区域的覆盖列表。  如果覆盖在区域中包含一个或多个字符，则覆盖与区域重叠；  空覆盖（参见空覆盖）重叠，如果它们在 beg，严格在 beg 和 end 之间，或者在 end 表示缓冲区可访问部分末尾的位置时。

 功能：next-overlay-change pos ¶

     此函数在 pos 之后返回覆盖的下一个开始或结束的缓冲区位置。  如果没有，则返回 (point-max)。

 功能：previous-overlay-change pos ¶

     此函数在 pos 之前返回覆盖的前一个开始或结束的缓冲区位置。  如果没有，则返回 (point-min)。

 例如，这是原始函数 next-single-char-property-change 的简化（且效率低下）版本（请参阅文本属性搜索函数）。  它从位置 pos 向前搜索下一个位置，从覆盖或文本属性获得的给定属性 prop 的值发生变化。

 (defun next-single-char-property-change (position prop)
   （保存游览
     （转到字符位置）
     (let ((propval (get-char-property (point) prop)))
       （而（和（而不是（eobp））
		   (eq (get-char-property (point) prop) propval))
	 (goto-char (min (next-overlay-change (point))
			 (next-single-property-change (point) prop)))))
     （观点）））

** TODO 40.10 显示文本的大小

由于并非所有字符都具有相同的宽度，因此这些函数可让您检查字符的宽度。  有关相关功能，请参阅缩进基元和按屏幕线移动。

 功能：字符宽度字符¶

     如果字符 char 显示在当前缓冲区中，则此函数返回以列为单位的宽度（即，考虑到缓冲区的显示表，如果有的话；请参阅显示表）。  制表符的宽度通常是制表符宽度（请参阅通常的显示约定）。

 功能：string-width string &optional from to ¶

     如果字符串显示在当前缓冲区和选定窗口中，则此函数返回以列为单位的宽度。  来自和指定要考虑的字符串的子字符串的可选参数，并被解释为在子字符串中（请参阅创建字符串）。

     返回值是一个近似值：它只考虑 char-width 为组成字符返回的值，总是将制表符作为制表符宽度列，忽略显示属性和字体等。出于这些原因，我们建议使用 window -text-pixel-size，如下所述。

 功能：truncate-string-to-width 字符串宽度&可选起始列填充省略号 ellipsis-text-property ¶

     此函数返回一个新字符串，它是字符串的截断，适合显示的宽度列。

     如果字符串比宽度窄，结果等于字符串；  否则结果中会省略多余的字符。  如果字符串中的多列字符超过目标宽度，则从结果中省略该字符。  因此，结果有时可能会低于宽度，但不能超过它。

     可选参数 start-column 指定起始列；  它默认为零。  如果这是非零，则从结果中省略字符串的第一个起始列。  如果字符串中的一个多列字符跨越列起始列，则省略该字符。

     可选参数填充（如果非零）是在结果字符串的开头和结尾添加的填充字符，以将其扩展到精确宽度的列。  如果宽度不足，则填充字符将附加在结果的末尾，达到宽度所需的次数。  如果字符串中的多列字符跨越列起始列，它也会在结果的开头添加。

     如果省略号是非零，它应该是一个字符串，当它被截断时将替换字符串的结尾。  在这种情况下，将从字符串中删除更多字符，以便为省略号释放足够的空间以适应宽度列。  但是，如果字符串的显示宽度小于省略号的显示宽度，则省略号不会附加到结果中。  如果 ellipsis 不是 nil 且不是字符串，则它代表函数 truncate-string-ellipsis 返回的值，如下所述。

     可选参数 ellipsis-text-property，如果非 nil，则表示使用显示省略号的显示文本属性（请参阅显示属性）隐藏字符串的多余部分，而不是实际截断字符串。

     （截断字符串到宽度“\tab\t”12 4）
	  ⇒ "ab"
     (截断字符串到宽度 "\tab\t" 12 4 ?\s)
	  ⇒ "ab"

     该函数使用 string-width 和 char-width 在字符串太宽时找到合适的截断点，因此它遇到与 string-width 相同的基本问题。  特别是，当字符组合发生在字符串中时，字符串的显示宽度可能小于组成字符的宽度之和，并且此函数可能返回不准确的结果。

 功能：截断字符串省略号¶

     此函数返回要在 truncate-string-to-width 和其他类似上下文中用作省略号的字符串。  该值是变量truncate-string-ellipsis的值，如果它不为nil，则如果该字符可以显示在所选帧上，则为具有单个字符U + 2026 HORIZONTAL ELLIPSIS的字符串，否则为字符串'...' .

 以下函数返回文本的大小（以像素为单位），就好像它显示在给定窗口中一样。  fit-window-to-buffer 和 fit-frame-to-buffer 使用此函数（请参阅调整窗口大小）使窗口与它包含的文本一样大。

 功能：window-text-pixel-size &optional window from to x-limit y-limit mode-lines ¶

     此函数返回窗口缓冲区文本的大小（以像素为单位）。  window 必须是活动窗口，并且默认为选定的窗口。  返回值是任何文本行的最大像素宽度和所有文本行的最大像素高度的组合。  此函数的存在是为了允许 Lisp 程序将窗口的尺寸调整为它需要显示的缓冲区文本。

     可选参数 from，如果非 nil，指定要考虑的第一个文本位置，默认为缓冲区的最小可访问位置。  如果 from 是 t，它代表不是换行符的最小可访问位置。  可选参数，如果非零，指定要考虑的最后一个文本位置，默认为缓冲区的最大可访问位置。  如果 to 是 t，它代表不是换行符的最大可访问位置。

     可选参数 x-limit，如果非 nil，则指定最大 X 坐标，超过该坐标应忽略文本；  因此，它也是函数可以返回的最大像素宽度值。  如果 x-limit nil 或省略，则表示使用窗口主体的像素宽度（参见窗口大小）；  此默认值意味着比窗口宽的截断行的文本将被忽略。  当调用者不打算更改窗口的宽度时，此默认值很有用。  否则，调用者应在此处指定窗口主体可能采用的最大宽度；  特别是，如果需要截断的行并且需要考虑其文本，则应将 x-limit 设置为较大的值。  由于计算长线的宽度可能需要一些时间，因此根据需要使这个参数尽可能小总是一个好主意；  特别是，如果缓冲区可能包含无论如何都会被截断的长行。

     可选参数 y-limit，如果非零，指定最大 Y 坐标，超过该坐标文本将被忽略；  因此，它也是函数可以返回的最大像素高度。  如果 y-limit 为 nil 或省略，则表示考虑所有文本行，直到 to 指定的缓冲区位置。  由于计算大缓冲区的像素高度可能需要一些时间，因此指定此参数是有意义的；  特别是，如果调用者不知道缓冲区的大小。

     可选参数 mode-lines nil 或省略表示在返回值中不包括窗口的模式行、制表行或标题行的高度。  如果它是符号模式行、制表行或标题行，则在返回值中仅包含该行的高度（如果存在）。  如果是 t，则在返回值中包含所有这些行的高度（如果存在）。

 window-text-pixel-size 将窗口中显示的文本视为一个整体，而不关心各行的大小。  下面的函数可以。

 功能：window-lines-pixel-dimensions & optional window first last body inverse left ¶

     此函数计算指定窗口中显示的每一行的像素尺寸。  它通过遍历窗口的当前字形矩阵来做到这一点——一个存储当前显示在窗口中的每个缓冲区字符的字形（参见字形）的矩阵。  如果成功，它会返回一个 cons 对列表，表示每行最后一个字符的右下角的 x 和 y 坐标。  坐标从窗口左上角的原点 (0, 0) 以像素为单位测量。  window 必须是活动窗口，并且默认为选定的窗口。

     如果可选参数 first 是一个整数，它表示要返回的窗口字形矩阵的第一行的索引（从 0 开始）。  请注意，如果窗口有标题行，则索引为 0 的行就是该标题行。  如果 first 为 nil，则要考虑的第一行由可选参数 body 的值确定：如果 body 为非 nil，这意味着从窗口主体的第一行开始，跳过任何标题行（如果存在）。  否则，此函数将从窗口字形矩阵的第一行开始，可能是标题行。

     如果可选参数 last 是一个整数，它表示应返回的窗口字形矩阵的最后一行的索引。  如果 last 为 nil，则要考虑的最后一行由 body 的值决定： 如果 body 为非 nil，这意味着使用窗口主体的最后一行，省略窗口的模式行（如果存在）。  否则，这意味着使用窗口的最后一行，它可能是模式行。

     可选参数 inverse，如果为 nil，则表示为任何行返回的 y 像素值指定从窗口的左边缘（如果 body 为非 nil，则为 body 边缘）到该窗口最后一个字形的右边缘的距离（以像素为单位）线。  inverse non-nil 表示为任何行返回的 y 像素值指定从该行的最后一个字形的右边缘到窗口的右边缘（如果 body 为非 nil，则为 body 边缘）的距离（以像素为单位）。  这对于确定每行末尾的松弛空间量很有用。

     可选参数 left，如果非 nil，则表示返回每行最左边字符的左下角的 x 和 y 坐标。  这是应该用于主要从右到左显示文本的窗口的值。

     如果 left 为非 nil 且 inverse 为 nil，这意味着为任何行返回的 y 像素值指定从该行的最后一个（最左侧）字形的左边缘到右边缘（如果body 是非 nil) 的窗口。  如果 left 和 inverse 都非 nil，则为任何行返回的 y 像素值指定从窗口的左边缘（如果 body 为非 nil，则为 body 边缘）到最后一个（最左边）的左边缘的距离（以像素为单位）那条线的字形。

     如果当前窗口的字形矩阵不是最新的，则此函数返回 nil，这通常发生在 Emacs 忙碌时，例如，在处理命令时。  该值应该是可检索的，尽管当此函数从一个延迟为零秒的空闲计时器运行时。

 功能：行像素高度¶

     此函数返回所选窗口中点的线的高度（以像素为单位）。  该值包括行的行距（请参阅行高）。

 当缓冲区显示行号时（参见 GNU Emacs 手册中的 Display Custom），有时了解显示行号所采用的宽度很有用。  以下函数适用于需要此信息进行布局计算的 Lisp 程序。

 功能：行号显示宽度&可选像素级¶

     此函数返回用于在选定窗口中显示行号的宽度。  如果可选参数 pixelwise 是符号列，则返回值是帧规范列的浮点数；  如果 pixelwise 是 t 或任何其他非零值，则该值是一个整数，以像素为单位。  如果 pixelwise 被省略或为零，则该值是为行号面定义的字体的整数列数，并且不包括用于填充显示数字的 2 列。  如果所选窗口中未显示行号，则无论pixelwise 的值如何，该值都为零。  如果您需要有关另一个窗口的信息，请使用 with-selected-window（请参阅选择窗口）。


** TODO 40.11 行高

每条显示行的总高度包括行内容的高度，加上显示行上方或下方可选的附加垂直行距。

 行内容的高度是该显示行上任何字符或图像的最大高度，包括最后一个换行符（如果有的话）。  （继续的显示行不包括最后的换行符。）如果您不指定更大的高度，那是默认的行高。  （在最常见的情况下，这等于相应框架的默认字体的高度，请参阅框架字体。）

 有几种方法可以显式指定更大的行高，或者通过指定显示行的绝对高度，或者通过指定垂直空间。  但是，无论您指定什么，实际行高都不能小于默认值。

 换行符可以具有行高文本或覆盖属性，用于控制以该换行符结尾的显示行的总高度。  属性值可以是以下几种形式之一：

 吨

     如果属性值为 t，则换行符对行的显示高度没有影响——可见内容单独决定了高度。  在这种情况下，也将忽略下面描述的行间距属性。  这对于平铺小图像（或图像切片）而不在图像之间添加空白区域很有用。
 （总高度）

     如果属性值是显示的表单列表，则会在显示行下方添加额外的空间。  首先 Emacs 使用 height 作为高度规范来控制线上方的额外空间；  然后它在线条下方添加足够的空间以使总线条高度达到总高度。  在这种情况下，换行符的任何 line-spacing 属性值都将被忽略。

 任何其他类型的属性值都是高度规范，它转换为一个数字——指定的行高。  有几种方法可以编写高度规范；  以下是它们每个转换为数字的方式：

 整数

     如果高度规范是一个正整数，那么高度值就是那个整数。
 漂浮

     如果高度规范是浮点数，浮点数，数字高度值是浮点数乘以框架的默认行高。
 （脸.比）

     如果高度规格是所示格式的缺点，则数字高度是比率乘以面部高度。  ratio 可以是任何类型的数字，或者 nil 表示比率为 1。如果 face 是 t，它指的是当前面。
 （零。比率）

     如果高度规范是所示格式的缺点，则数字高度是行内容高度的比率乘以。

 因此，任何有效的高度规范都会以一种或另一种方式确定以像素为单位的高度。  如果行内容的高度小于该值，Emacs 会在行上方添加额外的垂直空间以达到指定的总高度。

 如果不指定 line-height 属性，则行高由内容的高度加上行距组成。  有几种方法可以为 Emacs 文本的不同部分指定行距。

 在图形终端上，您可以使用 line-spacing frame 参数指定框架中所有行的行距（请参阅布局参数）。  但是，如果 line-spacing 的默认值不是 nil，它会覆盖框架的 line-spacing 参数。  一个整数指定放置在行下方的像素数。  浮点数指定相对于框架默认行高的间距。

 您可以通过 buffer-local line-spacing 变量指定缓冲区中所有行的行距。  一个整数指定放置在行下方的像素数。  浮点数指定相对于默认框架行高的间距。  这会覆盖为框架指定的行距。

 最后，换行符可以有一个行间距文本或覆盖属性，可以扩大默认帧行间距和缓冲区本地行间距变量：如果它的值大于缓冲区或帧默认值，则使用较大的值，对于以该换行符结尾的显示行。

 这些机制以一种或另一种方式为每行的间距指定一个 Lisp 值。  该值是一个高度规范，并且如上所述转换为 Lisp 值。  但是，在这种情况下，数字高度值指定了行间距，而不是行高。

 在文本终端上，行距不能更改。


** TODO 40.12 面

面是用于显示文本的图形属性的集合：字体、前景色、背景色、可选的下划线等。面控制 Emacs 如何在缓冲区中显示文本，以及框架的其他部分，例如模式行。

 表示人脸的一种方法是作为属性的属性列表，例如 (:foreground "red" :weight bold)。  这样的列表称为匿名面孔。  例如，您可以指定一个匿名人脸作为人脸文本属性的值，Emacs 将显示具有指定属性的底层文本。  请参阅具有特殊含义的属性。

 更常见的是，通过面部名称来引用面部：与一组面部属性相关联的 Lisp 符号24。  命名面是使用 defface 宏定义的（请参阅定义面）。  Emacs 带有几个标准的命名面（请参阅基本面）。

 Emacs 的某些部分需要命名面（例如，面属性函数中记录的函数）。  除非另有说明，否则我们将使用术语“人脸”来指代已命名的人脸。

 功能：facep 对象 ¶

     如果对象是一个命名的面，这个函数返回一个非零值：一个 Lisp 符号或字符串，用作面名。  否则，它返回零。

*** TODO 40.12.1 面属性

人脸属性决定了人脸的视觉外观。  下表列出了所有面部属性、它们的可能值及其效果。

 除了下面给出的值之外，每个人脸属性都可以具有未指定的值。  这个特殊值意味着面不直接指定该属性。  一个未指定的属性告诉 Emacs 引用父面（参见下面的描述 :inherit 属性）；  或者，如果失败，则到底层面（请参阅显示面）。  默认面必须指定所有属性。

 其中一些属性仅在某些类型的显示器上有意义。  如果您的显示器无法处理某个属性，则该属性将被忽略。

 ：家庭

     字体系列名称（字符串）。  有关字体系列的更多信息，请参阅 GNU Emacs 手册中的字体。  函数 font-family-list（见下文）返回可用家族名称的列表。
 :铸造厂

     由 :family 属性（字符串）指定的字体系列的字体代工厂的名称。  请参阅 GNU Emacs 手册中的字体。
 ：宽度

     相对字符宽度。  这应该是超压缩、超压缩、压缩、半压缩、正常、半扩展、扩展、超扩展或超扩展的符号之一。
 ：高度

     字体的高度。  在最简单的情况下，这是一个以 1/10 点为单位的整数。

     该值也可以是浮点数或函数，它指定相对于底层面的高度（请参阅显示面）。  浮点值指定底层面高度的缩放量。  使用一个参数调用函数值，即底层面的高度，并返回新面的高度。  如果函数被传递一个整数参数，它必须返回一个整数。

     必须使用整数指定默认面的高度；  不允许使用浮点和函数值。
 ：重量

     字体粗细——符号之一（从最密集到最微弱）超粗体、超粗体、粗体、半粗体、正常、半轻、轻、超轻或超轻。  在支持可变亮度文本的文本终端上，任何大于正常的粗细都显示为超亮，而任何小于正常的粗细都显示为半亮。
 ：倾斜

     字体倾斜 - 斜体、斜体、正常、反斜体或反斜体符号之一。  在支持可变亮度文本的文本终端上，倾斜的文本显示为半亮。
 ：前景

     前景色，一个字符串。  该值可以是系统定义的颜色名称，也可以是十六进制颜色规范。  请参阅颜色名称。  在黑白显示器上，某些灰色阴影由点画图案实现。
 :远景

     替代前景色，一个字符串。  这就像 :foreground 但仅当背景颜色接近本应使用的前景时，颜色才用作前景。  例如，这在标记文本（即区域面）时很有用。  如果文本具有区域面可见的前景，则使用该前景。  如果前景靠近区域面背景，则使用 :distant-foreground 代替，以便文本可读。
 ：背景

     背景颜色，一个字符串。  该值可以是系统定义的颜色名称，也可以是十六进制颜色规范。  请参阅颜色名称。
 ：强调

     字符是否应该加下划线，以及以什么方式。  :underline 属性的可能值是：

     零

	 不要下划线。
     吨

	 用脸部的前景色划线。
     颜色

	 颜色颜色下划线，指定颜色的字符串。
     (:color 颜色 :style 风格)

	 color 可以是字符串，也可以是符号 foreground-color，表示人脸的前景色。  省略 :color 属性表示使用人脸的前景色。  样式应该是符号线或波浪，意思是使用直线或波浪线。  省略属性 :style 意味着使用直线。

 :上划线

     字符是否应该被覆盖，以及用什么颜色。  如果值为 t，则覆盖使用面部的前景色。  如果该值是字符串，则上划线使用该颜色。  值 nil 表示不上划线。
 : 删除线

     字符是否应该被删除，以及用什么颜色。  该值的使用与 :overline 类似。
 ：盒子

     是否应围绕字符绘制框、其颜色、框线的宽度和 3D 外观。  以下是 :box 属性的可能值及其含义：

     零

	 不要画一个盒子。
     吨

	 用前景色绘制一个宽度为 1 的框。
     颜色

	 用颜色颜色画一个宽度为 1 的线框。
     (:line-width (vwidth .hwidth) :color 颜色 :style 样式)

	 这样，您可以明确指定框的所有方面。  vwidth 和 hwidth 值分别指定要绘制的垂直线和水平线的宽度；  它们默认为 (1 . 1)。  负的水平或垂直宽度 -n 表示绘制一条宽度为 n 的线，占据底层文本的空间，从而避免字符高度或宽度的任何增加。  为简化起见，可以仅使用单个数字 n 而不是列表来指定宽度，这种情况等效于 ((abs n) . n)。

	 值样式指定是否绘制 3D 框。  如果它是释放按钮，则该框看起来像未按下的 3D 按钮。  如果它是按下按钮，则该框看起来像被按下的 3D 按钮。  如果它是 nil、flat-button 或省略，则使用普通的 2D 框。

	 值 color 指定要绘制的颜色。  默认为 3D 框和平面按钮的面的背景颜色，以及其他框的面的前景色。

 :反向视频

     字符是否应以反向视频显示。  该值应为 t（是）或 nil（否）。
 :点画

     背景点画，位图。

     值可以是字符串；  这应该是包含外部格式 X 位图数据的文件的名称。  该文件位于变量 x-bitmap-file-path 中列出的目录中。

     或者，该值可以直接指定位图，带有表格的列表（宽度高度数据）。  这里，宽度和高度以像素为单位指定大小，数据是包含位图原始位的字符串，逐行。  每行占用字符串中的 (width + 7) / 8 个连续字节（为了获得最佳结果，应该是单字节字符串）。  这意味着每一行总是占据至少一个完整的字节。

     如果值为 nil，则表示不使用点画图案。

     通常不需要设置点画属性，因为它会自动用于处理某些灰色阴影。
 :字体

     用于显示人脸的字体。  它的值应该是一个字体对象或一个字体集。  如果它是一个字体对象，它指定了人脸用来显示 ASCII 字符的字体。  有关字体对象、字体规范和字体实体的信息，请参阅低级字体表示。  有关字体集的信息，请参阅字体集。

     当使用 set-face-attribute 或 set-face-font 指定此属性时（请参阅 Face Attribute Functions），您还可以提供字体规范、字体实体或字符串。  Emacs 将这些值转换为适当的字体对象，并将该字体对象存储为实际的属性值。  如果你指定一个字符串，字符串的内容应该是一个字体名称（参见 GNU Emacs 手册中的字体）；  如果字体名称是包含通配符的 XLFD，Emacs 会选择第一个匹配这些通配符的字体。  指定此属性还会更改 :family、:foundry、:width、:height、:weight 和 :slant 属性的值。
 ：继承

     要从中继承属性的面的名称，或面名称的列表。  继承面的属性会像底层面一样合并到面中，优先级高于底层面（请参阅显示面）。  如果未指定要继承的面，则将其视为 nil，因为 Emacs 从不合并 :inherit 属性。  如果使用面列表，则列表中较早面的属性会覆盖后面面的属性。
 ：延长

     此面是否会超出行尾并影响行尾和窗口边缘之间的空白区域的显示。  值应该是 t 以使用此面显示行尾和窗口边缘之间的空白空间，或者 nil 不使用此面作为行尾和窗口边缘之间的空间。  当 Emacs 合并几个面以显示超出行尾的空白空间时，只有那些具有 :extend 非 nil 的面会被合并。  默认情况下，只有少数人脸，特别是区域，具有此属性集。  此属性与其他属性的不同之处在于，当主题没有为面指定显式值时，将继承由 defface 定义的原始面定义的值（请参阅定义面）。

 功能：字体家族列表和可选框架¶

     此函数返回可用字体系列名称的列表。  可选参数 frame 指定显示文本的框架；  如果为 nil，则使用选定的帧。

 用户选项：下划线最小偏移量¶

     此变量指定显示下划线文本时基线和下划线之间的最小距离（以像素为单位）。

 用户选项：x-bitmap-file-path ¶

     此变量为 :stipple 属性指定用于搜索位图文件的目录列表。

 功能：bitmap-spec-p 对象 ¶

     如果 object 是有效的位图规范，则返回 t，适合与 :stipple 一起使用（见上文）。  否则返回 nil 。

*** TODO 40.12.2 定义面

*** TODO 40.12.3 人脸属性函数
*** TODO 40.12.4 显示面
*** TODO 40.12.5 人脸重映射
*** TODO 40.12.6 处理面的函数
*** TODO 40.12.7 自动人脸分配
*** TODO 40.12.8 基本面
*** TODO 40.12.9 字体选择
*** TODO 40.12.10 查找字体
*** TODO 40.12.11 字体集
*** TODO 40.12.12 低级字体表示
** TODO 40.13 条纹
*** TODO 40.13.1 条纹尺寸和位置
*** TODO 40.13.2 边缘指标
*** TODO 40.13.3 边缘光标
*** TODO 40.13.4 边缘位图
*** TODO 40.13.5 自定义边缘位图
*** TODO 40.13.6 叠加箭头
** TODO 40.14 滚动条
** TODO 40.15 窗口分隔线
** TODO 40.16 display财产
*** TODO 40.16.1 替换文本的显示规范
*** TODO 40.16.2 指定空间
*** TODO 40.16.3 空间的像素规范
*** TODO 40.16.4 其他显示规格
*** TODO 40.16.5 在边缘显示
** TODO 40.17 图像
*** TODO 40.17.1 图像格式
*** TODO 40.17.2 图像描述符
*** TODO 40.17.3 XBM 图像
*** TODO 40.17.4 XPM 图像
*** TODO 40.17.5 ImageMagick 图像
*** TODO 40.17.6 SVG 图像
*** TODO 40.17.7 其他图像类型
*** TODO 40.17.8 定义图像
*** TODO 40.17.9 显示图像
*** TODO 40.17.10 多帧图像
*** TODO 40.17.11 图像缓存
** TODO 40.18 嵌入式原生小部件
** TODO 40.19 按钮
*** TODO 40.19.1 按钮属性
*** TODO 40.19.2 按钮类型
*** TODO 40.19.3 制作按钮
*** TODO 40.19.4 操作按钮
*** TODO 40.19.5 按钮缓冲区命令
** TODO 40.20 抽象显示
*** TODO 40.20.1 抽象显示函数
*** TODO 40.20.2 抽象显示示例
** TODO 40.21 闪烁的括号
** TODO 40.22 字符显示
*** TODO 40.22.1 通常的显示约定
*** TODO 40.22.2 显示表格
*** TODO 40.22.3 活动显示表
*** TODO 40.22.4 字形
*** TODO 40.22.5 无字形字符显示
** TODO 40.23 哔哔声
** TODO 40.24 窗户系统
** TODO 40.25 工具提示
** TODO 40.26 双向显示
